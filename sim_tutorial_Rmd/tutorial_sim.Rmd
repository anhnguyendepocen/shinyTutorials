---
title: "Building an Instructional Simulation App in Shiny"
author: "Homer White"
date: "June 17, 2015"
output: html_document
runtime: shiny
---

## Introduction and Prerequisites

### Overview

Shiny makes it easy for R users to develop responsive, R-powered web applications.  As you probably know, either from your own initial forays into Shiny or from the [Shiny Tutorial](http://shiny.rstudio.com/tutorial/), creating simple apps is no problem, and probably you have some ideas for teaching apps that could be written using just the tools developed in the Tutorial.

But some teaching apps appear quite complex.  Consider, for example, [this app](http://homer.shinyapps.io/SlowGoodness) that aims to introduce the student to the $\chi^2$ Test for Goodness of Fit.  The app takes the user through a simulation process, keeping track of the results of simulations as they accumulate, permitting the viewer to consider the results from several points of view, and allowing the viewer to start over, perhaps with new data.

The aim of this tutorial is to take you step-by-step through the construction of a reasonably full-featured app that lets students explore, through simulation, the coverage properties of the classical t-intervals for a population mean.  After completing the tutorial you will be able to write your own simulation apps, hopefully being spared some of the struggle that I went through when I first learned Shiny in the Spring of 2014.

### Prerequisites

This tutorial assumes that you have:

* **familiarity with R**.  We'll assume some basic facility in R programming and that you can at least read and understand R code that creates custom plots in R's base graphics system.  For the most part our explanation of R code will be limited to its relationship to app-building.
* **an introductory knowledge of Shiny**.  All necessary prerequisites inthis area can be acquired by watching Garret Grolemund's excellent three-part webinar on *How to Stat with Shiny*.  (See R Studio's [webinars](http://www.rstudio.com/resources/webinars/) page.)

### Acquiring Source Code

All of the materials for this tutorial are avaialable in my GitHub repository:

>[https://github.com/homerhanumat/shinyTutorials](https://github.com/homerhanumat/shinyTutorials)

If you use Git, you could clone the repository into a new R Project.  Otherwise, simply visit the repository and click the `Download Zip` button.

## Version 1:  The Bare-Bones App

### The App

We'll start very simple confidence-interval app (below).  Play with it until you realize what it does.

```{r, echo=FALSE}
shinyAppDir(
  "example_sim_01/",
  options=list(
    width="100%", height=550
  )
)
```

### The Code

The complete code may be viewed  [here](https://github.com/homerhanumat/shinyTutorials/blob/master/example_sim_01/app.R)).  Since it's not a great deal of code, we also show it below:

```{r eval = FALSE}
## Initial App

library(shiny)
library(scales) # for transparency in density-plot fill

############################################################
## Set up the gamma-distributed population
###########################################################
shapeGamma <- 2
scaleGamma <- 50
xSkew <- seq(0,shapeGamma*scaleGamma+7.5*sqrt(shapeGamma)*scaleGamma,
             length.out=600)
ySkew <- dgamma(xSkew,shape=shapeGamma,scale=scaleGamma)
popDen <- list(x=xSkew,y=ySkew)
popMean <- shapeGamma*scaleGamma
yMax <- 1.5*max(popDen$y)

############################################################
## ui
############################################################

ui <- fluidPage(
  titlePanel('What Does "Confidence Level" Mean?'),
  sidebarPanel(
    sliderInput(inputId="n","Sample Size n",value=2,min=2,max=50,step=1),
    helpText("How confident do you want to be that the population mean is contained",
             "within the confidence interval?   Use the slider to select a desired",
             "percent-confidence level."),
    
    sliderInput(inputId="confLevel","Confidence Level",value=80,min=50,max=99,step=1),
    actionButton("takeSample","Sample Now")
    ), # end sidebarPanel
  mainPanel(
    plotOutput("plotSample")
    )  # end mainPanel
  )

#################################################################
## server
#################################################################

server <- function(input, output) {
  
  ## set seed so that users are likely to get different results
  set.seed(as.numeric(Sys.time()))
  
  rv <- reactiveValues(sample = NULL, 
                       mean = NULL, 
                       lower = NULL,
                       upper = NULL)
  
  observeEvent(input$takeSample, 
               {
                 # random sample and its mean
                 samp <- rgamma(input$n,shape=shapeGamma,scale=scaleGamma)
                 xbar <-  mean(samp)
                 # make bounds for the confidence interval
                 conf = isolate(input$confLevel/100)
                 t.input = conf + ((1 - conf)/2)
                 tMultiplier = qt(t.input, df = input$n - 1)
                 se = sd(samp)/sqrt(input$n)
                 margin = tMultiplier * se
                 # store in rv
                 rv$sample <- rgamma(input$n,shape=shapeGamma,scale=scaleGamma)
                 rv$mean <- xbar
                 rv$lower <- xbar - margin
                 rv$upper <- xbar + margin
                 }
               )
  
  
  output$plotSample <- renderPlot({
    # the underlying population
    plot(popDen$x,popDen$y,type="l",lwd=3,col="red",
         main="Density Curve of Population",
         xlab="",
         ylab="density",
         ylim = c(0,yMax))
    abline(v=popMean,lwd=2)
    # sample and interval
    if (input$takeSample) {
      # density plot for the sample
      sampDen <- density(rv$sample, from = 0)
      xdens <- sampDen$x
      ydens <- sampDen$y
      firstx <- xdens[1]
      lastx <- xdens[length(xdens)]
      polygon(x = c(firstx,xdens,lastx), y = c(0,ydens,0), col = alpha("lightblue",0.5))
      # now the interval
      intLevel <- 0.95*yMax
      segments(x0 = rv$lower, y0 = intLevel, x1 = rv$upper, y1 = intLevel, 
               col = "green", lwd = 3)
      text(x=rv$lower,y=intLevel,labels="(")
      text(x=rv$upper,y=intLevel,labels=")")
      points(rv$mean, intLevel, col = "blue", pch = 20,cex=2)
      rug(rv$sample)
      }
    })  # end plotSample
  } # end server

#######################################################
## knit the app
#######################################################

shinyApp(ui = ui, server = server)
```

### Discussion

The code determining the population is placed outside of the `ui()` and `server()` functions.  This means that it will be one only once, at the beginning of the R session, even if multiple users are viewing the app.  Since in thsi bare-bones version our users can't pick another population, it's most efficient to run the code once for everyone.

The code to set the randomizer seed:

```{r eval = FALSE}
  set.seed(as.numeric(Sys.time()))
```

appears inside the `ui()` function.  Hence it is one once for each user.  Since users are likely to app at different times, they are all likely to experience different results.  Usually this is what we desire when class members use an app together.

When the app begins, the `rv` list is created with the call to `reactiveValues()` and initially it contains some Null values.  The user may or may not select a new sample size and confidence level, but since the `rv` values have been set the `renderPlot()` function, having a body that contains these values, is obliged to spring into action and to make `output$plotSample`.  However, before the user requests a sample, the value of the action button, `input$takeSample` is 0.  Hence the `if` clause in `renderPlot()` will evaluate ot `FALSE` and the only thing produced is a density plot of the population.

If this app were a rock band, then `reactiveValues()` and `observeEvent()` would surely be the drummer and bass guitar player.  Working together, this pair makes the underlying rythm and helps the other players stay on track.  As soon as the user requests a sample, `observeEvent()` takes note of the fact.  This function:

* runs the code to produce a random sample of the desired size,
* computes a confidence interval of the desired level of confidence, and
* updates `rv` with the relevant information.

Since the elements of `rv` are all reactive, any change in any one of them suffices to invalidate `output$plotSample`.  Hnce R runs `renderPlot()` again.  As soon as the user requests a sample, `input$takeSample`, which began at 0, increases by one unit.  Hence in the `if` statement the condition `input$takeSample` will evaluate to `TRUE`---any nonzero integer evaluates to `TRUE`---and`renderPlot()` will therefore add the confidence interval to the density plot of the population.

This process will repeat every time the user requests a sample.  Since all positive integers evaluate to `TRUE`, the current confidence interval, as produced by `observeEvent()` and recorded in `rv`, will be added to the population curve.


## Version 2

Here is the second version:

```{r, echo=FALSE}
shinyAppDir(
  "example_sim_02/",
  options=list(
    width="100%", height=550
  )
)
```


## Version 3

Here is the third version:

```{r, echo=FALSE}
shinyAppDir(
  "example_sim_03/",
  options=list(
    width="100%", height=550
  )
)
```

## Version 4

Here is the fourth version:

```{r echo = FALSE}
shinyAppDir(
  "example_sim_04/",
  options=list(
    width="100%", height=650
  )
)
```

## Version 5

```{r echo = FALSE}
shinyAppDir(
  "example_sim_05/",
  options=list(
    width="100%", height=800
  )
)
```

## Version 6

```{r echo = FALSE}
shinyAppDir(
  "example_sim_06/",
  options=list(
    width="100%", height=800
  )
)
```


## Version 7

```{r echo = FALSE}
shinyAppDir(
  "example_sim_07/",
  options=list(
    width="100%", height=800
  )
)
```

You may also view the final version on the <a href = "http://homer.shinyapps.io/example_sim_07" target = "_blank">Web</a>.

Hope you enjoy!

## Cautions

### Output Objects Do Not Bilocate

Sometimes you want the same output to appear in two or more places in your app.  Suppose, for instance, that you want to show a contingency table on two different tab panels in a tab set.  You might try something like this:

```{r eval = FALSE}
library(shiny)

ui <- fluidPage(
  titlePanel('Sorry, No Bilocation!'),
  mainPanel(
    tabsetPanel(
      tabPanel(title = "Panel 1",
        tableOutput("crosstab")
        ),
      tabPanel(title = "Panel 2",
          tableOutput("crosstab")
        )
    )
  )
)

server <- function(input, output) {
  
  output$crosstab <- renderTable({
    xtabs(~ am + cyl, data = mtcars)
  })
  
}

shinyApp(ui = ui, server = server)
```

The result will be:

```{r echo = FALSE}
shinyAppDir(
  "repeating_output/",
  options=list(
    width="100%", height= 400
  )
)
```

The table fails to show in *both* panels!

To rectify this, you have to create distinct output objects.  If your objects require a lot of code, it's wise follow the DRY (Do not Repeat Yourself), and look for a way to put some of that code into a separate function, which is then called in the code that creates the objects.  In our small example, the DRY approach might look like this:

```{r eval = FALSE}
library(shiny)

ui <- fluidPage(
  titlePanel('DRY Bilocation'),
  mainPanel(
    tabsetPanel(
      tabPanel(title = "Panel 1",
        tableOutput("crosstab")
        ),
      tabPanel(title = "Panel 2",
          tableOutput("crosstab2")
        )
    )
  )
)
  
server <- function(input, output) {
  
  makeTable <- function() {
      xtabs(~ am + cyl, data = mtcars)
    }
    
    output$crosstab <- renderTable({
      makeTable()
    })
    
    output$crosstab2 <- renderTable({
      makeTable()
    })
  
}

shinyApp(ui = ui, server = server)
```

Now things work out:

```{r echo = FALSE}
shinyAppDir(
  "dry_bilocation/",
  options=list(
    width="100%", height= 400
  )
)
```

## Further Resources





