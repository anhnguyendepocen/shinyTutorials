---
title: "Building an Instructional Simulation App in Shiny"
author: "Homer White"
date: "June 17, 2015"
output: html_document
runtime: shiny
---

## Introduction and Prerequisites

### Overview

Shiny makes it easy for R users to develop responsive, R-powered web applications.  As you probably know, either from your own initial forays into Shiny or from the [Shiny Tutorial](http://shiny.rstudio.com/tutorial/), creating simple apps is no problem, and probably you have some ideas for teaching apps that could be written using just the tools developed in the Tutorial.

But some teaching apps appear quite complex.  Consider, for example, [this app](http://homer.shinyapps.io/SlowGoodness) that aims to introduce the student to the $\chi^2$ Test for Goodness of Fit.  The app takes the user through a simulation process, keeping track of the results of simulations as they accumulate, permitting the viewer to consider the results from several points of view, and allowing the viewer to start over, perhaps with new data.

The aim of this tutorial is to take you step-by-step through the construction of a reasonably full-featured app that lets students explore, through simulation, the coverage properties of the classical t-intervals for a population mean.  After completing the tutorial you will be able to write your own simulation apps, hopefully being spared some of the struggle that I went through when I first learned Shiny in the Spring of 2014.

Please feel free to copy and re-use the code in this repository:  It's under a General Public License.  You can also offer feedback on Git Hub by opening an Issue.

### Prerequisites

This tutorial assumes that you have:

* **familiarity with R**.  We'll assume some basic facility in R programming and that you can at least read and understand R code that creates custom plots in R's base graphics system.  For the most part our explanation of R code will be limited to its relationship to app-building.
* **an introductory knowledge of Shiny**.  All necessary prerequisites inthis area can be acquired by watching Garret Grolemund's excellent three-part webinar on *How to Stat with Shiny*.  (See R Studio's [webinars](http://www.rstudio.com/resources/webinars/) page.)

### Acquiring Source Code

All of the materials for this tutorial are available in my GitHub repository:

>[https://github.com/homerhanumat/shinyTutorials](https://github.com/homerhanumat/shinyTutorials)

If you use Git, you could clone the repository into a new R Project.  Otherwise, simply visit the repository and click the `Download Zip` button.

## Version 1:  The Bare-Bones App

### The App

We'll start very simple confidence-interval app (below).  Play with it until you realize what it does.

```{r, echo=FALSE}
shinyAppDir(
  "example_sim_01/",
  options=list(
    width="100%", height=550
  )
)
```

### The Code

The complete code may be viewed  [here](https://github.com/homerhanumat/shinyTutorials/blob/master/example_sim_01/app.R)).  Since it's not a great deal of code, we also show it below:

```{r eval = FALSE}
## Initial App

library(shiny)
library(scales) # for transparency in density-plot fill

############################################################
## Set up the gamma-distributed population
###########################################################
shapeGamma <- 2
scaleGamma <- 50
xSkew <- seq(0,shapeGamma*scaleGamma+7.5*sqrt(shapeGamma)*scaleGamma,
             length.out=600)
ySkew <- dgamma(xSkew,shape=shapeGamma,scale=scaleGamma)
popDen <- list(x=xSkew,y=ySkew)
popMean <- shapeGamma*scaleGamma
yMax <- 1.5*max(popDen$y)

############################################################
## ui
############################################################

ui <- fluidPage(
  titlePanel('What Does "Confidence Level" Mean?'),
  sidebarPanel(
    sliderInput(inputId="n","Sample Size n",value=2,min=2,max=50,step=1),
    helpText("How confident do you want to be that the population mean is contained",
             "within the confidence interval?   Use the slider to select a desired",
             "percent-confidence level."),
    
    sliderInput(inputId="confLevel","Confidence Level",value=80,min=50,max=99,step=1),
    actionButton("takeSample","Sample Now")
    ), # end sidebarPanel
  mainPanel(
    plotOutput("plotSample")
    )  # end mainPanel
  )

#################################################################
## server
#################################################################

server <- function(input, output) {
  
  ## set seed so that users are likely to get different results
  set.seed(as.numeric(Sys.time()))
  
  rv <- reactiveValues(sample = NULL, 
                       mean = NULL, 
                       lower = NULL,
                       upper = NULL)
  
  observeEvent(input$takeSample, 
               {
                 # random sample and its mean
                 samp <- rgamma(input$n,shape=shapeGamma,scale=scaleGamma)
                 xbar <-  mean(samp)
                 # make bounds for the confidence interval
                 conf = isolate(input$confLevel/100)
                 t.input = conf + ((1 - conf)/2)
                 tMultiplier = qt(t.input, df = input$n - 1)
                 se = sd(samp)/sqrt(input$n)
                 margin = tMultiplier * se
                 # store in rv
                 rv$sample <- rgamma(input$n,shape=shapeGamma,scale=scaleGamma)
                 rv$mean <- xbar
                 rv$lower <- xbar - margin
                 rv$upper <- xbar + margin
                 }
               )
  
  
  output$plotSample <- renderPlot({
    # the underlying population
    plot(popDen$x,popDen$y,type="l",lwd=3,col="red",
         main="Density Curve of Population",
         xlab="",
         ylab="density",
         ylim = c(0,yMax))
    abline(v=popMean,lwd=2)
    # sample and interval
    if (input$takeSample) {
      # density plot for the sample
      sampDen <- density(rv$sample, from = 0)
      xdens <- sampDen$x
      ydens <- sampDen$y
      firstx <- xdens[1]
      lastx <- xdens[length(xdens)]
      polygon(x = c(firstx,xdens,lastx), y = c(0,ydens,0), col = alpha("lightblue",0.5))
      # now the interval
      intLevel <- 0.95*yMax
      segments(x0 = rv$lower, y0 = intLevel, x1 = rv$upper, y1 = intLevel, 
               col = "green", lwd = 3)
      text(x=rv$lower,y=intLevel,labels="(")
      text(x=rv$upper,y=intLevel,labels=")")
      points(rv$mean, intLevel, col = "blue", pch = 20,cex=2)
      rug(rv$sample)
      }
    })  # end plotSample
  } # end server

#######################################################
## knit the app
#######################################################

shinyApp(ui = ui, server = server)
```

### Discussion

The code determining the population is placed outside of the `ui()` and `server()` functions.  This means that it will be one only once, at the beginning of the R session, even if multiple users are viewing the app.  Since in this bare-bones version our users can't pick another population, it's most efficient to run the code once for everyone.

The code to set the random seed:

```{r eval = FALSE}
  set.seed(as.numeric(Sys.time()))
```

appears inside the `ui()` function.  Hence it is one once for each user.  Since users are likely to app at different times, they are all likely to experience different results.  Usually this is what we desire when class members use an app together.

When the app begins, the `rv` list is created with the call to `reactiveValues()` and initially it contains some Null values.  The user may or may not select a new sample size and confidence level, but since the `rv` values have been set the `renderPlot()` function, having a body that contains these values, is obliged to spring into action and to make `output$plotSample`.  However, before the user requests a sample, the value of the action button, `input$takeSample` is 0.  Hence the `if` clause in `renderPlot()` will evaluate to `FALSE` and the only thing produced is a density plot of the population.

If this app were a rock band, then `reactiveValues()` and `observeEvent()` would surely be the drummer and bass guitar player.  Working together, this pair makes the underlying rhythm and helps the other players stay on track.  As soon as the user requests a sample, `observeEvent()` takes note of the fact.  This function:

* runs the code to produce a random sample of the desired size,
* computes a confidence interval of the desired level of confidence, and
* updates `rv` with the relevant information.

Since the elements of `rv` are all reactive, any change in any one of them suffices to invalidate `output$plotSample`.  Hence R runs `renderPlot()` again.  As soon as the user requests a sample, `input$takeSample`, which began at 0, increases by one unit.  Hence in the `if` statement the condition `input$takeSample` will evaluate to `TRUE`---any nonzero integer evaluates to `TRUE`---and`renderPlot()` will therefore add the density plot of the sample and the confidence interval to the density plot of the population.

This process will repeat every time the user requests a sample.  Since all positive integers evaluate to `TRUE`, the current sample and confidence interval, as produced by `observeEvent()` and recorded in `rv`, will be added to the population curve.


## Version 2:  Keep Track of Results

### The App

From Version 1 a persistent student could acquire some sense of coverage:  when the confidence level is set high, it will appear that the interval almost always covers the mean, etc.  But surely it would be better for the app to keep track of whether or not the interval covered the mean, and to report those results, in summary form, to the user.  Our second version accomplishes this.

Play with it a little:

```{r, echo=FALSE}
shinyAppDir(
  "example_sim_02/",
  options=list(
    width="100%", height=550
  )
)
```

### Code and Discussion

You can study the complete code [here](https://github.com/homerhanumat/shinyTutorials/blob/master/example_sim_02/app.R):  in what follows we'll point out the important additions.

First, note that `rv` contains two new values:  `rv$sim` and `rv$good`.

```{r eval = FALSE}
  rv <- reactiveValues(sample = NULL, 
                       mean = NULL, 
                       lower = NULL,
                       upper = NULL,
                       sims = 0,
                       good = 0)
```

`sims` keep track of the number of samples taken so far, and `good` records the number of those samples for which the interval covered the mean.  The tracking is accomplished in the call to `observeEvent()`:

```{r eval = FALSE}
                 goodInterval <- popMean >= lower & popMean <= upper

                  # ...
                  
                 rv$sims <- rv$sims + 1
                 rv$good <- rv$good + goodInterval
```

We have new output, created by a call to `renderTable()`:

```{r eval = FALSE}
  output$summary <- renderTable({
    df <- data.frame(rv$sims,
                     rv$good,
                     ifelse(rv$sims >0, round(rv$good/rv$sims*100,3), NA))
    names(df) <- c("Simulations", "Good Intervals", "Percentage Good")
    df
    }, include.rownames = FALSE)
```

In the above code, the argument `include,rownames = FALSE` is being passed to the function `xtable()` that creates a formatted table from the data frame `df`.  This prevents a useless row number from appearing in the resulting table.

## Version 3:  Conditional Panels

### The App

Version 2 keeps track, but right now that's worse than the memory-less Version 1.  What if the user changes the confidence level?  Then the summarized results don't make any sense.

We also want to study coverage properties for other populations besides the slightly skewed one that is provided for us.  If we were to add such a feature, then it would be wise to allow the app to start afresh.

The new version below addresses two of the above issues by adding a start-over feature.

```{r, echo=FALSE}
shinyAppDir(
  "example_sim_03/",
  options=list(
    width="100%", height=550
  )
)
```

### Code and Discussion

You can study the complete code [here](https://github.com/homerhanumat/shinyTutorials/blob/master/example_sim_03/app.R):  in what follows we'll discuss how the start-over feature was implemented.

The crucial Shiny concept here is the concept of a *conditional panel*.  We've got two in the sidebar panel and another in the main panel:

```{r eval = FALSE}
  sidebarPanel(
    conditionalPanel(
      condition = "input$takeSample == 0 || output.beginning == true",
      sliderInput(inputId="n","Sample Size n",value=2,min=2,max=50,step=1),
      helpText("How confident do you want to be that the population mean is contained",
             "within the confidence interval?   Use the slider to select a desired",
             "percent-confidence level."),
     sliderInput(inputId="confLevel","Confidence Level",value=80,min=50,max=99,step=1)
     ),
    actionButton("takeSample","Sample Now"),
    conditionalPanel(
      condition = 'output.beginning == false',
      actionButton("reset","Start Over")
      )
    ), # end sidebarPanel
  mainPanel(
    plotOutput("plotSample"),
    conditionalPanel(
        condition = 'output.beginning == false',
        tableOutput("summary")
        )
```

AS a Shiny programmer you can get by without thinking about JavaScript, with the one important exception:  conditional panels.  The `condition` argument takes a JavaScript Boolean expression.  You can could it up with operators that look like those of R, but note that the JavaScript Boolean values are lower case:  `true` and `false`.  You can refer to input and output objects, but you have to use a `.` in place of a `$`.  If you want to learn more about Boolean expression in JavaScript, start [here](http://www.w3schools.com/js/js_comparisons.asp).

We have a new action button, with value `input$reset`.  Hence there is a corresponding new `rv` value named `rv$beginning` that is initially set to `TRUE`:

```{r eval = FALSE}
  rv <- reactiveValues(sample = NULL, 
                       mean = NULL, 
                       lower = NULL,
                       upper = NULL,
                       sims = 0,
                       good = 0,
                       begin = TRUE)
```

Accordingly there is a new observer to perform appropriate updates to `rv` in response to the user's request to start over:

```{r eval = FALSE}
  observeEvent(input$reset,
               {
                 rv$sample <- NULL
                 rv$mean <- NULL
                 rv$lower <- NULL
                 rv$upper <- NULL
                 rv$sims <- 0
                 rv$good <- 0
                 rv$begin <- TRUE
                 }
               )
```

In order for the Boolean expressions in the conditional panels to express whether or not we are starting over, we need to create the appropriate output object:

```{r eval = FALSE}
  output$beginning <- reactive({
    rv$begin
  })
  
  # needed for the conditional panels to work
  outputOptions(output, 'beginning', suspendWhenHidden=FALSE)
```

The second statement in the code above is immensely important.  Sometimes an output is being shown to the user (for instance:  a plot in a tab panel that the user has selected), and at other times it may be hidden.  Since there is no `...Output()` function in any panel that displays `output$beginning` to the user, this object is always hidden.  Nevertheless, we want it to update whenever `rv$begin` changes value:  we don't want this hidden object to be "suspended."  `outputOptions()` permits us to force the object to be responsive at all times, even though it is never shown to the user.

Note finally the addition to the observer of `input$takeSample`:

```{r eval = FALSE}
  observeEvent(input$takeSample, 
               {
                 # ...
                 rv$begin <- FALSE
                 }
               )
```

As soon as a sample is requested, we want to get get away from the "set-up" elements of the sidebar panel, and to start adding the sample and confidence intervals to our plot.  We can now use `rv$begin` to control whether the sample and interval are to be added.  In the call to `renderPlot()` we now find:

```{r eval = FALSE}
    if (! rv$begin) {
      # density plot for the sample
      # ...
      # now the interval
      # ...
      rug(rv$sample)
      }
```

## Version 4:  Choose Your Population

### The App

The next version (below) permits the user at set-up to choose from four different populations.

```{r echo = FALSE}
shinyAppDir(
  "example_sim_04/",
  options=list(
    width="100%", height=650
  )
)
```

You can study the complete code [here](https://github.com/homerhanumat/shinyTutorials/blob/master/example_sim_04/):  once again our discussion will highlight new features.

First of all, note that setting up four populations requires a fairly long block of code.  In order to keep the `app.R` as brief and easy-to-scan as possible, we offload population creation to a separate R script (`setup.R`, here stored in the same directory as `app.R') and source it in at the beginning:

```{r eval = FALSE}
library(shiny)
library(scales) # for transparency in density-plot fill

## Set up underlying populations:
source("setup.R")
```

The crucial addition to `ui` is:

```{r eval = FALSE}
selectInput(inputId="popDist",label="Population Shape",
                  choices=list("Normal"="normal",
                               "Skewy"="skew",
                               "REALLY Skewed"="superskew",
                               "Way-Out Outlier Group"="outliers"))
```

Note that `selectInput()` appears inside of a conditional panel, in such a way that it is displayed only at the beginning and immediately after a request to start over.

For clarity in code the main panel now consists of two conditional panels:

```{r eval = FALSE}
  mainPanel(
    conditionalPanel(
      condition = "output.beginning == true",
      plotOutput("initialGraph")
      ),
    conditionalPanel(
      condition = 'output.beginning == false',
      plotOutput("plotSample"),
      tableOutput("summary")
        )
    ) # end MainPanel
```

We augment the `rv` list, initializing the new reactive objects to values pertaining to the Normal population option:

```{r eval = FALSE}
  rv <- reactiveValues(
    popDen = normalDen,
    popMean = normalMean,
    popMax = max(normalDen$x),
    popMin = min(normalDen$x),
    yMax = 1.5*max(normalDen$y),
    # ...
    )
```

Of course in `server` we need an observer for `input$popDist`:

```{r eval = FALSE}
  observeEvent(input$popDist,
               {
                 rv$popDen <- switch(input$popDist,
                                     normal=normalDen,
                                     skew=skewDen,
                                     superskew=superSkewDen,
                                     outliers=outlierDen)
                 rv$popMean <- switch(input$popDist,
                                      normal=normalMean,
                                      skew=skewMean,
                                      superskew=superSkewMean,
                                      outliers=outlierMean)
                 rv$popMax <- switch(input$popDist,
                                     normal=max(normalDen$x),
                                     skew=max(skewDen$x),
                                     superskew=max(superSkewDen$x),
                                     outliers=max(outlierDen$x))
                 rv$popMin <- switch(input$popDist,
                                     normal=min(normalDen$x),
                                     skew=min(skewDen$x),
                                     superskew=min(superSkewDen$x),
                                     outliers=min(outlierDen$x))
                 rv$yMax <- switch(input$popDist,
                                   normal=1.5*max(normalDen$y),
                                   skew=1.5*max(skewDen$y),
                                   superskew=1.5*max(superSkewDen$y),
                                   outliers=1.5*max(outlierDen$y))
                 }
               )
```


Other elements of the `server` code are suitably modified to respond to changes in the desired population.


## Version 5:  Choose the Number of Samples

### The App

It's good practice for students to start out with one simulation at a time.  This gives them a chance:

* to distinguish between population and sample, and
* to judge the effect of the distribution of a sample on the location and length of the confidence interval.

Once they get these points, however, they will want to achieve good estimates of the actual level of confidence by taking many, many samples.  The version below affords them such an opportunity.

```{r echo = FALSE}
shinyAppDir(
  "example_sim_05/",
  options=list(
    width="100%", height=900
  )
)
```

### Code and Discussion

You can study the complete code [here](https://github.com/homerhanumat/shinyTutorials/blob/master/example_sim_05/):  once again our discussion will highlight new features.

The set-up version of the sidebar panel has a new input widget:

```{r eval = FALSE}
    helpText("How many samples would you like to take at one time?  Limit is 10000. With each ",
             "sample, we'll make a confidence interval for the population mean."),
    numericInput("sims", "Number of Samples at Once", 1, min=0, max = simLimit, step=1)
```

Since the user can request as many as ten thousand samples at once, it would be wise to spend some space in order to save time in drawing and working with all these samples.  Rather than writing a `for` loop, we choose to draw all needed random items at once and to store them in a matrix, which we then manipulate.  This is accomplished in the new version of the observer of `input$takeSample`:

```{r eval = FALSE}
  observeEvent(input$takeSample, 
               {
                 # get the samples, make the intervals
                 n <- input$n
                 reps <- min(input$sims, simLimit)
                 # grab all the random items you need at once:
                 itemNumb <- reps*n
                 sampleItems <- switch(input$popDist,
                                       normal=rnorm(itemNumb,mean=muNorm,sd=sigmaNorm),
                                       skew=rgamma(itemNumb,shape=shapeGamma,scale=scaleGamma),
                                       superskew=rpareto(itemNumb,alpha=alphaPareto,theta=thetaPareto),
                                       outliers=routlier(itemNumb))
                 # arrange the random items in a matrix; the rows are your samples
                 sampleMatrix <- matrix(sampleItems,ncol=n,nrow=reps)
                 conf = input$confLevel/100
                 t.input = conf + ((1 - conf)/2)
                 tMultiplier = qt(t.input, df = n - 1)
                 # from the matrix, quickly compute the items you need
                 xbar <- rowSums(sampleMatrix)/n
                 se <- sqrt((rowSums(sampleMatrix^2)-n*xbar^2)/(n^2-n))
                 margin = tMultiplier * se
                 lower <- xbar - margin
                 upper <- xbar + margin
                 goodInterval <- ((rv$popMean > lower) & (rv$popMean < upper))
                 goodCount <- sum(goodInterval)
                 latestSamp <<- sampleMatrix[reps,]
                 # store in rv
                 rv$sample <- sampleMatrix[reps, ]
                 rv$mean <- xbar[reps]
                 rv$lower <- lower[reps]
                 rv$upper <- upper[reps]
                 rv$sims <- rv$sims + reps
                 rv$good <- rv$good + goodCount
                 rv$begin <- FALSE
                 })
```

Note that in the code above only the last sample (the final row in the matrix), is passed to `rv$sample`:

```{r eval = FALSE}
                 rv$sample <- sampleMatrix[reps, ]
```

Thus the plot shows only the most recent sample.

We have also added, to the conditional panel that contains the plot of the population with sample, a list of clarifying remarks:

```{r eval = FALSE}
    conditionalPanel(
      condition = 'output.beginning == false',
      plotOutput("plotSample"),
      HTML("<ul>
                <li>The population density curve is in red.</li>
                <li>The vertical line marks the population mean.</li>
                <li>A density plot for the most recent sample is in light blue.</li>
                <li>The most recent sample mean is the big blue dot.</li>
                <li>The most recent confidence interval is in green.</li>
              </ul>"),
      br(''),
      tableOutput("summary")
      )
```

The more complex the app becomes, the more you want to give the user by way of explanation.


## Version 6:  Tabset Panels

### The App

Suppose that our students are told about how t-interval are made from the t-statistic.  Then they are liable to have been told as well about how the nominal levels of confidence for t-interval are derived from quantiles of the relevant t-curve, that the nominal and actual levels of confidence are the same provided that the t-statistic has exactly a t-curve distribution, and that departures from normality in the population therefore are liable to result in differences between the nominal and actual levels of confidence.

In order to reduce (somewhat) the probability that this such theory-talk will be discounted entirely by students, we could opt to look at our app results from a new point of view:  we could compare the "theoretical" t-curve with a density plot of the t-statistics associated with each of the samples that have been taken so far.  The next version of the app (below), implements this comparison.

```{r echo = FALSE}
shinyAppDir(
  "example_sim_06/",
  options=list(
    width="100%", height=900
  )
)
```

### Code and Discussion.

You can study the complete code [here](https://github.com/homerhanumat/shinyTutorials/blob/master/example_sim_06/):  once again our discussion will highlight new features.

In the `ui`, the main panel now contains conditional panel that takes the form of a tab-set:

```{r eval = FALSE}
    conditionalPanel(
      condition = "output.beginning == false",
      tabsetPanel(
        tabPanel(title = "Latest Interval",
                 plotOutput("plotSample"),
                 HTML("<p> </p>"),
                 HTML("<ul>
                        <li>The population density curve is in red.</li>
                        <li>The vertical line marks the population mean.</li>
                        <li>A density plot for the sample is in light blue.</li>
                        <li>The sample mean is the big blue dot.</li>
                        <li>The confidence interval is in green.</li>
                      </ul>"),
                br(''),
                tableOutput("summary")
                ),
        tabPanel(title = "t-statistic",
                 plotOutput("tstatistic"),
                 HTML(
                   "<p>The plots above compare the actual distribution of the t-statistic
                      to the t-curve with n-1 degrees of freedom.</p>
                    <p></p>
                    <ul>
                      <li>The t-curve is in red.  If the population is exactly normal, 
                        then this curve represents the exact distribution of the t-statistic.</li>
                      <li>The density plot of the t-statistics found so far is shown in blue.  
                          This plot gives a pretty good estimate of the actual distribution of the                                    t-statistic, for the population and sample size that you have selected.</li>
                    </ul>")
                 )
        ) # end tabset panel
      ) # end conditonal panel
```

Naturally, we augment `rv` with a value to record the t-statistics that have will be computed:

```{r eval = FALSE}
  rv <- reactiveValues(
    # ...
    tstats = numeric())
```

We add to `rv$tstats` in the observer of `input$takesSample`:

```{r eval = FALSE}
observeEvent(input$takeSample, 
               {
                 # ...
                 rv$tstats <- c(rv$tstats, (xbar-rv$popMean)/se)
               })
```

The observer of `input$reset` is also modified:

```{r eval = FALSE}
  observeEvent(input$reset,
               {
                 # ...
                 rv$tstats <- numeric()
               })
```

The code that produces the t-statistic density plot requires careful choice of band-width in order to produce reasonably informative plots when very few samples have been taken:

```{r eval = FALSE}
  output$tstatistic <- renderPlot({
    input$takeSample
    n <- input$n
    numberSims <- rv$sims
    tstats <- rv$tstats
    if (numberSims == 1) {
      tstatDen <- density(tstats,n=1024,from=-10,to=10,bw=1)
      }
    if (numberSims >= 2 && n < 5) {
      tstatDen <- density(tstats,n=1024,from=-10,to=10,bw=0.1)
      }
    if (numberSims >= 2 && n >= 5) {
      tstatDen <- density(tstats,n=1024,from=-10,to=10,bw="SJ")
      }
    if (numberSims > 0) {
      ymax <- max(tstatDen$y,dt(0,df=n-1))
      plot(tstatDen$x,tstatDen$y,type="l",lwd=2,col="blue",
           main="t-statistic vs. t-curve",cex.main=2,
           xlab="t", ylim=c(0,ymax),xlim=c(-6,6),
           ylab="density")
      curve(dt(x,df=n-1),-6,6,col="red",lwd=2,add=TRUE)
      } #end check that there are samples
  })
```



## Version 7:  Incorporate a Related App

### The App

Could the user learn something by viewing several confidence intervals at once?  The app below provides such an option.  It also a tab containing information about the app.

```{r echo = FALSE}
shinyAppDir(
  "example_sim_07/",
  options=list(
    width="100%", height=900
  )
)
```

If you wish you may also view this final version in isolation on the <a href = "http://homer.shinyapps.io/example_sim_07" target = "_blank">Web</a>.

### Code and Discussion

You can study the complete code [here](https://github.com/homerhanumat/shinyTutorials/blob/master/example_sim_07/):  once again our discussion will highlight new features.


When you examine the file structure of the source code on GitHub, you will notice that we have switched from single-file format(`app.R`) to the older two-file format (`ui.R` and `server.R`).  It's good to do this as your code gets longer.

The overall structure of the user interface is provided by `navbarPage()`:

```{r eval = FALSE}
navbarPage(
  title = 'Exploring Confidence Intervals',
  tabPanel(title = "Coverage Properties",
           #...
           ),
           mainPanel(
             conditionalPanel(
               condition = "input.takeSample == 0 || output.beginning == true",
               # ...
               ),
             conditionalPanel(
               condition = "output.beginning == false",
               tabsetPanel(
                 id = "coverageTabsetPanel",
                 tabPanel(
                   title = "Latest Interval",
                   # ...
                   ),
                 tabPanel(
                   title = "t-statistic",
                   # ...
                   )
                 )
               )
             )
           ),
  tabPanel(
    title = "Fifty at a Time",
    sidebarPanel(
      conditionalPanel(
        condition = "input.takeSample2 == 0 || output.beginning2 == true",
        selectInput(
          inputId="popDist2",
          label="Population Shape",
          choices=list("Normal"="normal",
                       "Skewy"="skew",
                       "REALLY Skewed"="superskew",
                       "Way-Out Outlier Group"="outliers")
          ),
        br()
        ),
      sliderInput(inputId="n2","Sample Size n",value=2,min=2,max=50,step=1),
      helpText("How confident do you want to be that the population mean is contained",
               "within the confidence interval?   Use the slider to select a desired",
               "percent-confidence level."),
      sliderInput(inputId="confLevel2","Confidence Level",value=80,min=50,max=99,step=1),
      actionButton("takeSample2","Fifty Samples Now"),
      conditionalPanel(
        condition = 'output.beginning2 == false',
        actionButton("reset2","Start Over")
        )
      ),
    mainPanel(
      conditionalPanel(
        condition = "input.takeSample2 == 0 || output.beginning2 == true",
        plotOutput("initialGraph2"),
        HTML("<ul>
                <li>The population density curve is in red.</li>
                <li>The vertical line marks the population mean.</li>
             </ul>")
        ),
      conditionalPanel(
        condition = "output.beginning2 == false",
          plotOutput("plotSample2"),
          HTML("<ul>
                  <li>The population density curve is in red.</li>
                  <li>The vertical line marks the population mean.</li>
                  <li>Intervals covering the mean are green.</li>
                  <li>Intervals NOT covering the mean are in burlywood.</li>
               </ul>"),
          tableOutput("summary2")
        )
      )
    ),
  navbarMenu(
    title = "More",
    tabPanel(
      title = "Help",
      includeHTML("infoFiles/help.html")
      ),
    tabPanel(
      title = "About",
      includeHTML("infoFiles/aboutapp.html")
      )
    )
  )
```


The aim is to make the "fifty-at-a-time" app function independently of the original "coverage properties" app.  Accordingly it requires its own set of inputs and outputs:  hence the considerable increase in the amount of code.

Note also that two information HTML files appear in their own subdirectory `infoFiles`.  This is done because they are each being generated by corresponding R Markdown files (`help.Rmd` and `aboutapp.Rmd`)  Since Shiny servers can host R markdown documents and are therefore disposed to look for them in the root directory, the R Markdown files should not appear at the root level.

By now the app has gotten become fairly flexible and informative.  Still I'm sure that you can think of a few extra bells and whistles to add.  if you teach bootstrap intervals, you might might want to incorporate the app into them somehow (or do away with the old-fashioned t-interval entirely).  You are welcome to proceed as you wish.  My intent has not been to create One App to Rule Them All, but rather to persuade you that you can design a better app on your own, without much more than the R knowledge that you already possess.


## Cautions, and Further Resources

### Caution:  Output Objects Do Not Bilocate

Sometimes you want the same output to appear in two or more places in your app.  Suppose, for instance, that you want to show a contingency table on two different tab panels in a tab set.  You might try something like this:

```{r eval = FALSE}
library(shiny)

ui <- fluidPage(
  titlePanel('Sorry, No Bilocation!'),
  mainPanel(
    tabsetPanel(
      tabPanel(title = "Panel 1",
        tableOutput("crosstab")
        ),
      tabPanel(title = "Panel 2",
          tableOutput("crosstab")
        )
    )
  )
)

server <- function(input, output) {
  
  output$crosstab <- renderTable({
    xtabs(~ am + cyl, data = mtcars)
  })
  
}

shinyApp(ui = ui, server = server)
```

The result will be:

```{r echo = FALSE}
shinyAppDir(
  "repeating_output/",
  options=list(
    width="100%", height= 200
  )
)
```

The table fails to show in *both* panels!

To rectify this, you have to create distinct output objects.  If your objects require a lot of code, it's wise follow the DRY (Do not Repeat Yourself), and look for a way to put some of that code into a separate function, which is then called in the code that creates the objects.  In our small example, the DRY approach might look like this:

```{r eval = FALSE}
library(shiny)

ui <- fluidPage(
  titlePanel('DRY Bilocation'),
  mainPanel(
    tabsetPanel(
      tabPanel(title = "Panel 1",
        tableOutput("crosstab")
        ),
      tabPanel(title = "Panel 2",
          tableOutput("crosstab2")
        )
    )
  )
)
  
server <- function(input, output) {
  
  makeTable <- function() {
      xtabs(~ am + cyl, data = mtcars)
    }
    
    output$crosstab <- renderTable({
      makeTable()
    })
    
    output$crosstab2 <- renderTable({
      makeTable()
    })
  
}

shinyApp(ui = ui, server = server)
```

Now things work out:

```{r echo = FALSE}
shinyAppDir(
  "dry_bilocation/",
  options=list(
    width="100%", height= 250
  )
)
```

### Further Resources

#### R Studio Resources

R Studio provides excellent, up-to-date documentation on Shiny in a series of [articles](http://shiny.rstudio.com/articles/).  Every single one of them is worth reading.  You will also find yourself consulting their [function reference](http://shiny.rstudio.com/reference/shiny/latest/).  Finally, the [gallery](http://shiny.rstudio.com/gallery/) is an excellent source of inspiration (and code to copy and modify).

#### shinyjs

[Dean Attali](http://deanattali.com/) is the author of the `shinyjs` package, a collection of useful add-on functions.  Instructors may be especially interested in:

* the `show`, `hide` and `toggle` functions.  They come with options for animation, and so allow you to gently disclose or hide various items such as input widgets.
* the `info` function, to provide a helpful pop-up message.

Dean also has some useful tutorials in the form of blog posts.  See especially:

* [Mimicking a Google Form with a Shiny App](http://deanattali.com/2015/06/14/mimicking-google-form-shiny/);
* [How to get your very own RStudio Server and Shiny Server with DigitalOcean](http://deanattali.com/2015/05/09/setup-rstudio-shiny-server-digital-ocean/).  If you run your own Shiny Server at your institution, this post contains great IT advice on how to make Shiny apps run as desired.

